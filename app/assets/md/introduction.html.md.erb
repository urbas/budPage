# Introduction

<div class="alert alert-info">
  <span class="label label-primary">Note:</span> This document describes Bud's architecture.
  Use <a href="<%= Rails.application.routes.url_helpers.pages_path('docs/guide') %>">the guide</a>
  if you want to start using Bud without going into nitty-gritty details.
</div>

Bud is a build tool. It takes care of your C# projects. Bud is all about automating
build-related processes. For example, Bud will fetch the dependencies of your projects,
build the projects, run, test, package, and publish them for you. You can also customise
your processes through normal C# code.

In the simplest case, you don't have to configure Bud at all. Just place
some C# files in the `Your.Project/src/main/cs` folder and invoke `bud run`.

Bud's configuration is written in C#. No XMLs or DSLs, just a plain C# file:
`Your.Project/.bud/Build.cs`. In this file you can
specify multiple projects, their dependencies, and add other customisations
to the build process.

## Concepts

### The `Build` class

Bud expects you to write a class called `Build` in your `Your.Project/.bud/Build.cs` file.
This class defines your entire build. The only requirement is that it must implement the
`Bud.IBuild` interface:

```language-csharp
namespace Bud {
  public interface IBuild {
    Settings Setup(Settings buildSettings, string baseDir);
  }
}
```

Bud will compile the `Build.cs` file and create a DLL. This DLL is from then on loaded when you
run Bud. Execution of the build is therefore as swift as executing regular C# code.
Here's how a simple `Build.cs` file looks like:

```language-csharp
using Bud;
using Bud.CSharp;
using Bud.Projects;

public class Build : IBuild {
  public Settings Setup(Settings settings, string baseDir) {
    var projectFoo = new Project("Foo", baseDir, Cs.Exe());
    return settings.Add(projectFoo);
  }
}
```

The particular example above adds an executable project, called Foo, to the build. 
You can now place some C# files into the `src/main/cs` folder and then invoke
`bud run`. This will compile your C# files, create the `Foo.exe` executable, and
run it.


### The `Settings` class

### Build definition

A __build definition__ is a collection of key-value pairs. There are two types of keys: `ConfigKey` and
`TaskKey`. Every key has a path, such as `/project/Foo.Bar/main/cs/baseDir` or
`/build`. A value can be of any .NET type.

A value of a config key is evaluated when it is accessed for the first time. It is evaluated
once per lifetime of the build definition. A value of a task key is evaluated once per root-level task
invocation (i.e.: if a task calls another task twice, its value is evaluated once only and in the second
invocation the cached value is used).

You define values of config keys and task keys by building them up (i.e., you add small modifiers to a
`Settings` instance). For example, you can introduce your own key and value by calling
`settings.Add(MySettings.HelloWorldMessage.Init("Hello, World!"))`. The parameter to the
`Add` method is a modifier. This modifier initialises the
`HelloWorldMessage`
key with the value `"Hello, World!"` (if it has not been initialised before in `settings`).
You can define your own config and task keys like this:

```language-csharp
public static readonly ConfigKey<string> HelloWorldMessage = Key.Define("helloWorldMessage", "Prints a hello world message in the log.");

public static readonly TaskKey HelloWorld = Key.Define("helloWorld", "Prints a hello world message in the log.");
```

<div class="alert alert-info">
  <span class="label label-primary">Note:</span> The <code>Settings</code> class is immutable. Therefore,
  <code>settings.Add(...)</code> returns
  a new instance instead of mutating the existing one.
</div>